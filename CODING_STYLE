ABS CODING STYLE
================================================================================

1. Introduction
--------------------------------------------------------------------------------
Following a consistent coding style makes the job of reading and interpreting
software between developers easier, increasing the possibilities of
collaboration between developers. A coding style also helps in the debugging
because it clearly lays out the functionality of the program: the code is
self-documented.

These rules should be followed from the very beginning, and not introduced
later. Anything that is left for later is prone to not being done.


2. Line width
--------------------------------------------------------------------------------
Line width is 80 characters; not longer. Code, and especially patches, is much 
more readable if limited to a sane line length. This length also makes it easier
to embed code in DIN-A4 documents.


3. Whitespace
--------------------------------------------------------------------------------
 - Indents are four spaces. Tabs are forbidden for identation purposes unless 
   they are a language or syntax request (e.g. Makefiles).
 - Separate parameters in functions with one space:
        function(param1, param2, param3);
 - Opeands and operators must be separated with (at least) one space at each 
   side of the operation:
        b = a + 1;
 - Extra spaces can be optionally added to improve readability only when several 
   operations can be aligned together. In this situation, the alignment should
   be ideally done with the equal (=) symbol:
        b    = a + 1;
        c_2  = b * 4;
        c_2 *= a;
<<<< Options:
------------- Marc:
 - Put spaces between conditional statements and the first parentheses:
        while (x > 0)
------------- Carles:
>>>>
 - Do not leave whitespace dangling off the ends of lines.
 - Leave one empty line between logical groups of instructions.
 - Leave one empty line between functions.


4. Block structure
--------------------------------------------------------------------------------
 - Braced blocks of code must be properly indented.
 - Every indented statement is braced; even if the block contains just one
   statement. 
 - Flow control statements must not contain spaces between the name and 
   conditions/arguments.
        if(condition)   /* Wrong.   */
        if (condition)  /* Correct. */
 - Blocks containing a single statement can skip the braces if and only if they 
   fit in a single line, e.g.: 
        if(condition) op = 42;
   The purpose of this rule is only to shrink the SLOC number and should *never* 
   worsen readability. Nesting is not allowed without braces:
        for(int i = 0; i < N; i++)          /*          */
            for(int j = 0; j < N; j++)      /* Wrong.   */
                for(int k = 0; k < N; k++)  /*          */
                    single_line();          /*          */

        for(int i = 0; i < N; i++) if(condition) single_line(); /* Wrong.*/
         
        for(int i = 0; i < N; i++)
        {
            for(int i = 0; i < N; i++)
            {
                for(int i = 0; i < N; i++) single_line();   /* Correct. */
            }
        }
 - For flow control statements (if, while, for, switch):
     - The opening brace must be in the same line that contains the flow control
       statement and must be preceeded by a space; 
     - the closing brace is in a new line; 
     - the "} else ... {" statement is in a single new line;
     - braces are separated one space from the rest of the line (if any).
     - Example:
        if(a == 5) {                /* One space before "{".                */
            printf("a was 5.\n");   /* Identation is applied.               */
        } else if(a == 6) {         /* Padding spaces next to braces.       */
            printf("a was 6.\n");
        } else {                    /* All in one new line.                 */
            printf("a was something else entirely.\n");
        }
        for(i = 0; i < 3; i++) {    /* Braces are optional here because the */
            printf("i is %d\n", i); /* inner part of the block is short     */
        }                           /* enough to write it on a single line. */
 - Functions:
    - Both opening and closing braces must be written in a new line.
    - No blank lines can be included right after or before the opening and 
      closing braces, respectively.
    - Example:
        int a_function(void)
        {                   /* New line.                                    */
            do_something(); /* No space between prev. line and this one.    */
                            /* Blank lines here ARE allowed.                */
            return 0;       /* No space after the return line.              */
        }                   /* New line.                                    */

 - Switch control blocks must be indented setting the "case ...:" and "default:"
   keywords at a different level than the body of the condition. Example:
        switch(var) {                           /* Same rules.              */
            case 1:                             /* 1 indent. step applied.  */
            case 2:
            case 3:
                printf("Var is 1, 2 or 3\n");   /* 2 indent. steps applied. */
                break;                          /* 2 indent. steps applied. */
            case 4:
                printf("Var is 4\n");
                break;
            default:
                printf("Var is not 1, 2, 3 or 4\n");
                break;
        }


5. Naming
--------------------------------------------------------------------------------
 - Variables and functions are lower_case_with_underscores; easy to type and
   read.
 - Structured and enum type names are in CamelCase; harder to type but standing
   out.
 - Scalar type names are lower_case_with_underscores_ending_with_a_t, like the
   POSIX uint64_t and similar families.
 - Constants are UPPER_CASE_WITH_UNDERSCORES; to stand out.
 - Global symbols include the domain of which they are part:
        syscore_init_start
        syscore_init_clean
        syscore_power_flag
 - When wrapping standard library functions, use the prefix abs_ to alert
   readers that they are seeing a wrapped version; otherwise avoid this prefix:
        abs_malloc


6. Declarations
--------------------------------------------------------------------------------
 - Mixed declarations (i.e. interleaving statements and declarations within 
   blocks) are not allowed; declarations should be at the beginning of blocks. 
   In other words, the code should not generate warnings if using GCC's
   -Wdeclaration-after-statement option.
 - Global variables initialization should be ideally performed within the body 
   of the entry point (main) or an initialization handler. Avoid initializing a
   global variable outside a function scope and at several source files. Try to 
   use constants instead of hardcoded expressions when possible. 


7. Static and Extern
--------------------------------------------------------------------------------
 - All data global for one file, and all auxiliar functions to that file must
   have the static keyword. Do not make global what it is not necessary.
 - Global functions and variables must be declared in the header file using the 
   "extern" modificatior. Their definition must be coded in the source files 
   where they are used (except functions). Example:
        /* ---- example.h: -----*/
        extern int example_global;
        extern char state_global;
        extern void my_function();
        
        /* ---- example1.c: ----*/
        int example_global;
        static private_function()
        {
            /* Function that uses example_global varaible. */
        }
        
        /* ---- example2.h: ----*/
        char state_global;
        void my_function()
        {
            /* Function that uses state_global variable. */
        }
        
        
8. Headers
--------------------------------------------------------------------------------
 - Each source file must have one single header file. Their names must match 
   (except in the extension) and the header file should include all libraries
   and external headers. The source file should contain only one #include 
   directive.
 - Header files must contain all constants, macros, type definitions, and global
   function prototypes and variables. 
 - Header files must have a conditional compilation with a descriptive name 
   given its domain and file name, and finish with a _H:
        #ifndef APPMOD_H
        #define APPMOD_H
        ...
        #endif
 - Only include what is needed. Avoid including what it is not needed (i.e. 
   unused libraries, old headers...)
 - C/C++ macros and complex constants (i.e. those which are calculated at 
   compile-time) are there to save time, reduce lines of code, improve 
   readability and mitigate typo-like errors. Use them with care, though, and 
   don't forget to wrap complex expressions with parentheses. Example:
        #define A   3
        #define B   4
        /* ---- case 1: */
        #define C   A + B 
        #define D   A * C   /* The result will be 13. */
        /* ---- case 2: */
        #define C   (A + B) 
        #define D   (A * C) /* The result will be 21. */
        

9. Comments and in-code documentation
--------------------------------------------------------------------------------
 - Use in-code comments rationally. There's no need to comment each and every 
   line but it is very important to comment on decisions made, obscure hacks or 
   other parts which might be difficult to understand.
 - Always surround the comments with /* */. Do not use other methods such as //.
 - Comments are English sentences: although short and clear, they must be 
   grammatically correct. Do use punctuation (commas, full stops, parentheses 
   and hyphens) and a proper language (e.g. avoid slang words, use technical 
   expressions).
 - Functions and files must be documented according to the JavaDoc (for Java 
   code), PlDoc (for Prolog code) and Doxygen (for the rest of the languages)
   specifications.


11. Reliability, debug easiness and flexibility
--------------------------------------------------------------------------------
 - Based on Holzmann's "The Power of Ten: Rules for Developing Safety Critical 
   Code", NASA/JPL Laboratory for Reliable Software, available at
   <http://spinroot.com/gerard/pdf/Power_of_Ten.pdf>, the following rules should 
   be applied to the software developed for ABS. Their rationale is detailed in 
   the aforementioned paper. (TODO, modify/remove some of these rules if 
   necessary)
        1.  Restrict all code to very simple control flow constructs –do not use 
            goto statements, setjmp or longjmp constructs, and direct or 
            indirect recursion. 
            Exception: "goto" statements can be used to implement cleaning 
            sections before the return of a function. The purpose of this rule 
            is only to provide an easy way to clean/free multiple resources 
            which could have not been gained due to partial errors. Example:
                int function()
                {
                    int error;
                    if((error = do_something(1)) < 0) goto clean3;
                    if((error = do_something(2)) < 0) goto clean2;
                    if((error = do_something(3)) < 0) goto clean1;
                clean1:
                    undo_something(3);
                clean2:
                    undo_something(2);
                clean3:
                    undo_something(1);
                    return error;
                }
        2.  All loops must have a fixed upper-bound. It must be trivially
            possible for a checking tool to prove statically that a preset 
            upper-bound on the number of iterations of a loop cannot be 
            exceeded. If the loop-bound cannot be proven statically, the rule is 
            considered violated.
        3.  Reduce the number of dynamic allocations to the minimum possible. If
            the size of memory blocks can be predicted (at compile time), it is
            compulsory to declare the memory region size statically.
            Pointers are allowed only when there's a clear justification for 
            them. If a section initializes a memory block (i.e. calls some of 
            the malloc() family functions) it is strictly mandatory to include 
            complementary free calls. 
        4.  No function should be longer than what can be printed on a single 
            sheet of paper in a standard reference format with one line per 
            statement and one line per declaration. Typically, this means no 
            more than about 100 lines of code per function.
        5.  The assertion density of the code should average to a minimum of two 
            assertions per function. Assertions are used to check for anomalous 
            conditions that should never happen in real-life executions. 
            Assertions must always be side-effect free and should be defined as 
            Boolean tests. When an assertion fails, an explicit recovery action 
            must be taken, e.g., by returning an error condition to the caller 
            of the function that executes the failing assertion. Any assertion 
            for which a static checking tool can prove that it can never fail or 
            never hold violates this rule. (I.e., it is not possible to satisfy 
            the rule by adding unhelpful “assert(true)” statements.)
            A typical use of an assertion would be as follows:
                if(!c_assert(p >= 0) == true) 
                {
                    return ERROR;
                }
            with the assertion defined as follows:
                #define c_assert(e) ((e) ? (true) : \
                    tst_debugging("%s,%d: assertion '%s' failed\n", \
                    __FILE__, __LINE__, #e), false)
            In this definition, __FILE__ and __LINE__ are predefined by the 
            macro preprocessor to produce the filename and line-number of the 
            failing assertion. The syntax #e turns the assertion condition e 
            into a string that is printed as part of the error message. In code 
            destined for an embedded processor there is of course no place to 
            print the error message itself – in that case, the call to 
            tst_debugging is turned into a no-op, and  the assertion turns into 
            a pure Boolean test that enables error recovery from anomolous 
            behavior.
        7.  The return value of non-void functions must be checked by each 
            calling function, and the validity of parameters must be checked 
            inside each function.
        9.  The use of pointers should be restricted. Specifically, no more than 
            one level of dereferencing is allowed. Pointer dereference 
            operations may not be hidden in macro definitions or inside typedef 
            declarations. Function pointers are only permitted when the have a
            direct and clear justification.
        10. All code must be compiled, from the first day of development, with 
            all compiler warnings enabled at the compiler’s most pedantic 
            setting. All code must compile with these setting without any 
            warnings. All code must be checked daily with at least one, but 
            preferably more than one, state-of-the-art static source code 
            analyzer and should pass the analyses with zero warnings. 
            (see <http://spinroot.com/static/index.html>)


12. Final remarks
--------------------------------------------------------------------------------
 - Any code modifications accepted into the master tree must be compliant with 
   these sets of rules and must compile without warnings using the -Wall option.
 - New code must be provided together with a Makefile. Including README 
   temporary files within certain folders is allowed (and recommended) to save 
   time (and headaches) to the rest of the team.
   


